# Fastfile for Earn & Learn iOS App
# https://docs.fastlane.tools
#
# WORKFLOW:
# - Builds & TestFlight: Xcode Cloud
# - Metadata: Fastlane (this file)
# - Screenshots: Managed manually in App Store Connect

default_platform(:ios)

platform :ios do
  # ==========================================
  # Setup & Configuration
  # ==========================================

  # before_all do
  #   # Uncomment to require clean git state before running
  #   ensure_git_status_clean unless is_ci
  # end

  # ==========================================
  # Metadata Management
  # ==========================================

  desc "Upload all metadata to App Store Connect"
  lane :upload_metadata do
    api_key = app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )

    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_screenshots: true,
      skip_metadata: false,
      force: true,
      precheck_include_in_app_purchases: false
    )
    UI.success("Metadata uploaded successfully!")
  end

  desc "Download current metadata from App Store Connect"
  lane :download_metadata do
    deliver(
      skip_binary_upload: true,
      skip_screenshots: true,
      skip_metadata: false,
      force: true,
      run_precheck_before_submit: false,
      metadata_path: "./fastlane/metadata"
    )

    # Actually download (deliver init downloads)
    sh("cd .. && fastlane deliver download_metadata --force")
    UI.success("Metadata downloaded to fastlane/metadata/")
  end

  # ==========================================
  # App Store Connect Setup
  # ==========================================

  desc "Create a new app on App Store Connect"
  lane :create_app do
    # Set up API key (used automatically by produce)
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )

    produce(
      app_identifier: "app.earnandlearn.ios",
      app_name: "Earn & Learn",
      language: "English",
      app_version: "1.0.0",
      sku: "earnandlearn001"
    )
    UI.success("App created on App Store Connect!")
  end

  desc "Sync app information from App Store Connect"
  lane :sync_app_info do
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )

    # This will show current app status
    deliver(
      skip_binary_upload: true,
      skip_screenshots: true,
      skip_metadata: true,
      precheck_include_in_app_purchases: false,
      run_precheck_before_submit: true
    )
  end

  # ==========================================
  # Local Testing (Optional)
  # ==========================================

  desc "Run tests locally"
  lane :test do
    run_tests(
      project: "./AllowanceTracker/AllowanceTracker.xcodeproj",
      scheme: "AllowanceTracker",
      device: "iPhone 16 Pro",
      clean: true
    )
  end

  # ==========================================
  # Validation
  # ==========================================

  desc "Validate metadata before upload"
  lane :validate do
    # Check metadata files exist
    required_files = [
      "metadata/en-US/name.txt",
      "metadata/en-US/subtitle.txt",
      "metadata/en-US/description.txt",
      "metadata/en-US/keywords.txt",
      "metadata/en-US/privacy_url.txt",
      "metadata/en-US/support_url.txt",
      "metadata/review_information/demo_user.txt",
      "metadata/review_information/demo_password.txt"
    ]

    missing = required_files.reject { |f| File.exist?(f) }

    if missing.any?
      UI.user_error!("Missing metadata files: #{missing.join(', ')}")
    end

    # Validate character limits
    name = File.read("metadata/en-US/name.txt").strip
    subtitle = File.read("metadata/en-US/subtitle.txt").strip
    keywords = File.read("metadata/en-US/keywords.txt").strip
    promo = File.read("metadata/en-US/promotional_text.txt").strip rescue ""
    description = File.read("metadata/en-US/description.txt").strip

    errors = []
    errors << "Name too long (#{name.length}/30)" if name.length > 30
    errors << "Subtitle too long (#{subtitle.length}/30)" if subtitle.length > 30
    errors << "Keywords too long (#{keywords.length}/100)" if keywords.length > 100
    errors << "Promotional text too long (#{promo.length}/170)" if promo.length > 170
    errors << "Description too long (#{description.length}/4000)" if description.length > 4000

    if errors.any?
      UI.user_error!(errors.join("\n"))
    end

    UI.success("All metadata validated successfully!")
    UI.message("Name: #{name.length}/30 chars")
    UI.message("Subtitle: #{subtitle.length}/30 chars")
    UI.message("Keywords: #{keywords.length}/100 chars")
    UI.message("Promotional: #{promo.length}/170 chars")
    UI.message("Description: #{description.length}/4000 chars")
  end

  desc "Run precheck to validate App Store compliance"
  lane :precheck_app do
    precheck(
      app_identifier: "app.earnandlearn.ios",
      include_in_app_purchases: false
    )
  end

  # ==========================================
  # Utility Lanes
  # ==========================================

  desc "Print current app version from Xcode project"
  lane :version do
    version = get_version_number(
      xcodeproj: "./AllowanceTracker/AllowanceTracker.xcodeproj"
    )
    build = get_build_number(
      xcodeproj: "./AllowanceTracker/AllowanceTracker.xcodeproj"
    )
    UI.message("Current version: #{version} (#{build})")
  end

  desc "Increment version number"
  lane :bump_version do |options|
    increment_version_number(
      xcodeproj: "./AllowanceTracker/AllowanceTracker.xcodeproj",
      bump_type: options[:type] || "patch" # major, minor, patch
    )
    version
  end

  # ==========================================
  # Error Handling
  # ==========================================

  error do |lane, exception|
    UI.error("Lane #{lane} failed with error: #{exception.message}")
  end
end
